# vim: filetype=bash

function check_bin {
    type -P "$1" 2>&1 >/dev/null
}

function modify_var {
    local varname=${1:?variable name}
    local sep=${2:?separator}
    local mode=${3:?\"append\" or \"prepend\"}
    local text=${4:?value}
    local value="${!varname}"
    if [[ ! $value ]] ; then
        value="$text"
    elif [[ "$sep$value$sep" == *"$sep$text$sep"* ]] ; then
        return
    elif [[ "$mode" == append ]] ; then
        value="${value%$sep}$sep$text"
    elif [[ "$mode" == prepend ]] ; then
        value="$text$sep${value#$sep}"
    else
        echo mode: append or prepend 1>&2
        return 1
    fi
    printf -v $varname %s "$value"
}

function prepend_path {
    modify_var PATH : prepend "$1"
    export PATH
}

function mcd {
    mkdir -p "$1" && cd "$1"
}
complete -A directory mcd

function tmux-clip {
    # load text from standard input to the tmux copy buffer
    # -w sends the input to system clipboard via OSC sequence
    tmux load-buffer -w -
}

function tmux-fixssh {
    # update all SSH environment variables in the pane
    eval $(tmux show-env -s | grep '^SSH_')
}
export -f tmux-fixssh

function source_if_exists {
    [[ -e $1 ]] && source "$1"
}

function osc52 {
    printf "\x1b]52;c;%s\x07" "$(base64)"
}

function venv {
    declare -a options=(--upgrade-deps)
    local OPTIND=1
    while getopts ":s" option; do
        case $option in
            s)  options+=(--system-site-packages)
                ;;
            *)  printf >&2 "Usage: %s [-s] [directory]\nOptions:\n" "${FUNCNAME[0]}"
                printf >&2 " -s    Enable site packages (--system-site-packages)\n"
                return 1
                ;;
        esac
    done
    shift $((OPTIND -1))
    declare dir="${1:-.venv}"
    [[ -d "${dir}" ]] || python3 -m venv "${options[@]}" "${dir}"
    source "${dir}/bin/activate"
}
complete -A directory -W "-s" venv

function complete_alias_as {
    local alias=${1:?alias name expected}
    local command=${2:?command name expected}
    local completion="$(complete -p $command 2>/dev/null | sed "s/^complete \(.*\) $command\$/\1/")"
    [[ $completion ]] && complete $completion $alias
}

function complete_alias_as_arcomplete {
    local alias=${1:?alias name expected}
    local command=${2:?command name expected}

    # Get the completion function for the original command
    local comp_func=$(complete -p "$command" 2>/dev/null | sed -n 's/.*-F \([^ ]*\).*/\1/p')

    if [[ -z "$comp_func" ]]; then
        echo "Warning: No completion function found for '$command'" >&2
        return 1
    fi

    # Create a wrapper function that transforms alias to command
    local wrapper_name="_complete_${alias}_wrapper"
    eval "
    $wrapper_name() {
        # Calculate length difference for COMP_POINT adjustment
        local alias_len=${#alias}
        local cmd_len=${#command}
        local len_diff=\$((cmd_len - alias_len))

        # Only replace alias at start of COMP_LINE (word boundary)
        if [[ \"\$COMP_LINE\" == \"$alias \"* ]] || [[ \"\$COMP_LINE\" == \"$alias\" ]]; then
            COMP_LINE=\"$command\${COMP_LINE:\$alias_len}\"
            COMP_POINT=\$((COMP_POINT + len_diff))
        fi

        # Replace alias with command in COMP_WORDS[0]
        COMP_WORDS[0]=\"$command\"

        # Call the original completion function with proper arguments
        # \$1 = command name, \$2 = current word, \$3 = previous word
        $comp_func \"\${COMP_WORDS[0]}\" \"\${COMP_WORDS[COMP_CWORD]}\" \"\${COMP_WORDS[COMP_CWORD-1]}\"
    }
    "

    # Register the wrapper function for the alias
    complete -F "$wrapper_name" "$alias"
}

function lsbranch {
   git rev-parse --is-inside-work-tree >/dev/null || return 1
   local mainBranch="$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@.*/@@')"
   local format="%C(auto)%h %<(30)%D%C(reset) %<(60)%s %C(auto,blue)%>>(12)%cr %C(auto,red)%>(14)%ar%C(reset)"
   git rev-list --no-commit-header --pretty="$format" --branches=* --single-worktree ^"$mainBranch"
}

function gerrit-latest {
    local review_id="${1:?need gerrit review id}"
    local refs=$(git ls-remote $(git remote get-url origin) "*/$review_id/*" | awk '/[0-9]+$/ {print $2}')
    [[ -n "$refs" ]] && { sort -rV | head -n 1; } <<<"$refs"
}
